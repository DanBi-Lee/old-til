---
description: Ajax
---

# 서버 연계로 고급 UI 구현하기

## 서버 연계로 고급 UI 구현하기 - Ajax

{% hint style="info" %}
2020.3.22  공부 , 책 : [**자바스크립트 마스터**](http://www.yes24.com/Product/Goods/44324818)
{% endhint %}

**Ajax\(Asynchronous JavaScript + XML\)**

* **개념**
  * 자바스크립트 객체를 이용해 서버 측과 비동기 통신을 실시한 후, 응답받은 결과를 DOM 경유로 페이지에 반영하는 구조
* **차이점**
  * 동기
    * 서버 통신을 실시할 때마다 결과가 반환되는 것 대기해야 함
    * 페이지 전체 리프레쉬
  * 비동기
    * 서버가 처리 중인 상황에서 클라이언트 측에서 조작 가능
    * 필요한 부분만 갱신
    * 클라이언트/서버 간의 트래픽 양 최소화

### PHP의 'Hello, World'와 Ajax의 'Hello, World'비교

* PHP 1. 결과를 표시할 때 페이지 전체가 다시 작성된다. 2. 서버와 통신하고 있는 동안 클라이언트 측은 조작을 계속할 수 없다.
* Ajax
  * Ajax 애플리케이션 구현 요소
    * 클라이언트 측에서 동장하는 파일 \(HTML\)
    * 서버 측에서 동장하는 파일\(예를들어 php 스크립트\)
  * PHP와의 차이
    * 결과를 표시할 때 페이지의 **필요한 부분만** 고쳐쓴다.
    * 서버 통신 중에도 클라이언트 측은 계속 조작할 수 있다.
  * 세 가지 이점 1. 조작성의 개선
    * 통신마다 발생하던 페이지의 깜빡임 해소
    * 서버가 처리 중일때도 클라이언트 측에서는 처리를 계속 실행 가능
      1. 퍼포먼스의 향상
    * 페이지의 필요한 부분만 갱신하므로 통신량 최소한으로 억제
    * 서버의 처리 종료를 기다릴 필요가 없기 때문에 체감 속도 향상
      1. 개발 생산성/운용성 향상
    * 고품격의 유저 인터페이스를 브라우저 표준의 기술만으로 구축할 수 있다.
    * 동작을 위한 별도의 특수 플러그인을 필요로 하지 않기 때문에 도입이 용이

예를 들어, 블로그 투고란에서 편집 중의 내용을 정기적으로 자동 보존하는 것이 실현하기 어려웠지만, Ajax 기술을 이용하여 사용자들이 굳이 신경쓰지 않아도 배후에서 처리가 가능해졌다.

### Ajax 애플리케이션 구현의 기본

* 서버와의 통신
  1. XMLHttpRequest 객체 생성
  2. 서버 통신 시의 처리 정의
  3. 비동기 통신을 개시

#### **1. XMLHttpRequest 객체 생성**

```javascript
let 변수이름 = new XMLHttpRequest();
```

XMLHttpRequest 객체가 비동기 통신을 관리한다. 이 객체를 이용함으로써 지금까지 브라우저가 실행해온 서버와의 통신 부분을 JavaScript가 제어할 수 있게 된다.

**XMLHttpRequest 객체로 이용 가능한 멤버** `*` : 읽기전용 `**` : send 메소드의 성공 시에만 유효

* 프로퍼티
  * `*`**response** : 응답 본체 취득
  * `*`**readyState** : HTTP 통신 상태 취득
  * `*`**responseText** : 응답 본체를 plaintext로 취득
  * **responseType** : 응답의 타입
  * `*`**responseXML** : 응답 본체를 XML\(XMLDocument 객체\)형태로 취득
  * `*`**status** : HTTP Status 코드를 취득
  * `*`**statusText** : HTTP Status의 상세 메시지 취득
  * **timeout** : 요청을 자동적으로 종료할 때까지의 시작
  * **withCredentials** : 크로스 오리진 통신 시 인증 정보를 송신할 것인가
  * **onreadystatechange** : 통신 상태가 변화된 타이밍에 호출되는 이벤트 핸들러
  * **ontimeout** : 요청이 타임아웃 하는 타이밍에 호출되는 이벤트 핸들러
* 메소드
  * **abort\(\)** : 현재의 비동기 통신을 중단
  * `**`**getAllResponseHeaders\(\)** : 수신한 모든 HTTP 응답 헤더를 취득
  * `**`**getResponseHeader\(header\)** : 지정한 HTTP 응답 헤더를 취득
  * **open\( ... \)** : HTTP 요청을 초기화\(구문의 상세 설명은 나중에\)
  * **setRequestHeader\(header, value\)** : HTTP 요청 시 송신하는 헤더를 추가
  * **send\(body\)** : HTTP 요청을 송신\(인수 body는 요청 본체\)

**XMLHttpRequest**라는 이름임에도 불구하고 통신에 이용하는 데이터 형식/프로토콜은 XML, HTTP에 한정되는 것이 아니다. 예를 들어 responseText 프로퍼티를 이용함으로써 일ㅇ반텍스트, HTML문자열, JSON문자열을 받을 수도 있다.

XMLHttpRequest : 클라이언트/서버 간의 일반적인 통신을 담당하는 객체다.

#### **2. 서버 통신 시 처리 정의**

XMLHttpRequest 객체를 생성했으면, onreadystatechange프로퍼티로 통신 시작부터 종료까지 실행해야 할 처리를 정의한다.

* onreadychange : 통신 상태가 변화한 타이밍에 호출되는 이벤트 핸들러
  * 서버로부터 정상적인 응답을 받아들인 타이밍에 페이지 갱신 처리를 실시한다
  * 서버로부터 에러가 반환되었을 경우에 에러 메시지를 표시한다
  * 서버에서의 통신을 시작한 타이밍에 '통신 중...'메시지를 표시한다.
* readyState 프로퍼티의 반환값

  | 반환값 | 개요 |
  | :--- | :--- |
  | 0 | 미초기화\(open 메소드가 호출되지 않음\) |
  | 1 | 로드 중\(open 메소드는 호출됐지만, send 메소드는 호출되지 않음\) |
  | 2 | 로드 완료\(send 메소드는 호출됐지만, 응답 스테이터스/헤더는 미취득\) |
  | 3 | 일부 응답을 취득\(응답 Status/헤더만 취득, 본체는 미취득\) |
  | 4 | 모든 응답 데이터 취득 완료 |

* status 프로퍼티의 반환값 \(주요 응답 status\)

  | 반환값 | 개요 |
  | :--- | :--- |
  | 200 | OK\(처리 성공\) |
  | 401 | Unauthorized\(인증이 필요\) |
  | 403 | Forbidden\(액세스가 거부되었다\) |
  | 404 | Not Found\(리퀘스트 된 자원이 존재하지 않는다\) |
  | 500 | Internal Server Error\(내부 서버 에러\) |
  | 503 | Service Unavailable\(요구한 서버 이용 불가\) |

서버로부터 응답을 취득하는 프로퍼티에`responseText`/`responseXML`/`response` 세가지가 존재. 일반적인 텍스트를 취득하려면 responseText 프로퍼티를 이용하면 된다.

응답에 따라 각각 아래와 같은 메시지를 표시한다.

* 서버로부터 응답이 반환되지 않는 경우\(readyState 프로퍼티가 4 이외\)
  * 진행 중임을 알리는 메시지
* 응답을 취득했으나 서버측에서 무언가 에러가 발생하고 있는\(status 프로퍼티가 200 이외인 경우\)
  * 에러메시지

> Note. **진행 중임을 알리는 메시지를 나타내는 것은 개발자의 책임** 비동기 통신에서는 통신 상황을 눈에 보이도록 하는 것이 없다. 그 때문에 정상적인 처리중이어도 최종 사용자는 현재 상태를 인식하기 힘들다. 이것은 사용자가 버튼을 두 번 눌러 버리거나 페이지를 리로드하는 등 불필요한 조작이 발생하는 원인이 될 수도 있다. Ajax 애플리케이션에 있어서 사용자에게 현재의 통신 상태를 명시적으로 나타내는 것은 애플리케이션 개발자의 책임임을 명심해야 한다.

#### **2'. 서버 통신 시 처리 정의 \(E\)**

XMLHttpRequest 객체에는 다음과 같은 이벤트가 준비되어 있어 이들을 이용하여 통신 시의 처리를 정의할 수도 있다.

| 이벤트 | 발생 타이밍 |
| :--- | :--- |
| loadstart | 요청을 송신했을 때 |
| progress | 데이터를 송수신하고 있는 중 |
| timeout | 요청이 타임 아웃했을 때 |
| abort | 요청이 취소되었을 때 |
| load | 요청이 성공했을 때 |
| error | 요청이 실패했을 때 |
| loadend | 정상/비정상에 상관 없이 요청이 완료 되었을 때 |

#### **3. 서버와의 통신 시작**

요청 데이터\(request\)를 서버세 송신하려면, 우선 open 메소드로 요청을 설정한다.

```javascript
xhr.open(method, url [, async [, user[, passwd]]])
    xhr : XMLHttpRequest 객체
    method : HTTP 메소드 (GET/POST/PUT/DELETE)
    url : 액세스된 url
    async : 비동기 통신 여부 (디폴트는 true)
    user : 인증시 사용자명
    passwd : 인증 시 암호
```

GET 메소드로 데이터를 송신하려면 URL의 말미에 다음과 같은 형식으로 데이터를 추가한다. \(이러한 정보를 쿼리 정보라고 부른다\)

```text
?키명=값& ...
```

값은 멀티바이트 문자나 그 외의 예약어가 포함되어 있는 경우를 대비하여, encodeURIComponent 함수로 encode 처리해두는 것이 좋다.

> Memo. **크로스 오리진 지정은 불가** 보안상의 이유로 원칙적으로는 XMLHttpRequest.open 메소드에 다른 오리진을 지정할 수 없다. 기존 브라우저에서는 동일 오리진이라고 할지라도 호스트명을 명시하는 것 자체만으로 올바르게 처리할 수 없는 것도 있기 때문에 주의해야 했다. open 메소드의 URL은 반드시 상대 패스로 지정해야 한다.

요청 준비가 되면 마지막으로 send 메소드를 이용해 요청을 송신한다. send 메소드의 인수는 open 메소드를 POST로 지정햇을 경우에만 요청 본체를 지정할 수 있다. GET으로 지정했다면 null로 지정해두자. send 메소드에 의한 리퀘스트 결과는 onreadystatechange 프로퍼티에 지정한 콜백 함수로 처리가 가능하다.

#### **POST 데이터 처리하기**

GET 메소드는 약간의 데이터를 송신하는 데 편리하지만 송신할 수 있는 정보량에 제한이 있다. 수백 바이트를 넘는 데이터를 송신하는 경우에는 통상적으로 POST를 이용하는 것이 좋다.

POST 메소드를 사용하는 경우에는 송신부분을 GET과 다르게 쓴다. 포인트는 두가지다.

1. Content-Type 헤더에 'application/x-www-urlencoded; charset=UTF-8'을 지정
   * Content-Type 헤더는 리퀘스트 데이터의 형태를 나타내기 위한 정보다. Content-Type 헤더를 명시하고 있지 않는 경우에는 사용하고 있는 브라우저에 따라 제대로 데이터를 송신할 수 없게 될 가능성도 있기 때문에 주의가 필요하다.
2. 요구 데이터는 send 메소드의 인수로 지정

{% hint style="info" %}
이후로 추가로 공부하여 업데이트 예정...
{% endhint %}

### Ajax 애플리케이션에서 구조화 데이터 다루기

### 클라이언트 측에서 크로스 오리진 통신 가능하게 하기

JSONP

### 크로스 도큐먼트 메시징을 통한 그로스 오리진 통신

